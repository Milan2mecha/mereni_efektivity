/**
  ******************************************************************************
  * @file     lib.c
  * @author   Auto-generated by STM32CubeIDE
  * @version  V1.0
  * @date     19/09/2024 19:17:24
  * @brief    Default under dev library file.
  ******************************************************************************
*/

/* Includes ------------------------------------------------------------------*/
#include "stm32f1xx_hal.h"
#include "ADS121X.h"
extern I2C_HandleTypeDef hi2c1;
int32_t offset = 0;

/*---------------------------*/
/*   Základní práce s reg    */
/*---------------------------*/

//čtení ADC (tested)
int32_t ADS121X_read(void)
{
  uint8_t buff[3];
  int32_t out = 0;
  HAL_I2C_Mem_Read(&hi2c1, (ADS121X_addr<<1), 0x10, 1, buff, 3, 10);
  out = (uint32_t)buff[0]<<24;
  out |= (uint32_t)buff[1]<<16;
  out |= (uint32_t) buff[2] << 8;
  out = out >>8;
  return out;
}

// Čtení registru nastavení (tested)
uint8_t ADS121X_RREG(uint8_t num)
{
  uint8_t status  = 0;
  HAL_I2C_Mem_Read(&hi2c1, (ADS121X_addr<<1), (0b00100000 | (num<<2)), 1, &status, 1, 10);
  return status;
}

//příkaz start (tested)
void ADS121X_start(void){
  uint8_t cmd = 0x08;
  HAL_I2C_Master_Transmit(&hi2c1, (ADS121X_addr<<1), &cmd, 1 , 10);
}

//je k dispozici výsledek nové konverze pokud ano vrátí 1 (tested)
uint8_t ADS121X_ready(void){
  if ((ADS121X_RREG(1)&0x80)==0)
  {
    return 0;
  }else{
    return 1;
  }
}

//vypnutí
void ADS121X_POWERDOWN(void){
  static uint8_t PD = 0x02;
  HAL_I2C_Master_Transmit(&hi2c1, (ADS121X_addr<<1), &PD , 1, 100);
}

//zapsání registru (tested)
uint8_t ADS121X_WREG(uint8_t command){
   uint8_t cmdW [2] = {0x40, 0x00};
   cmdW[1] = command;
   HAL_I2C_Master_Transmit(&hi2c1, (ADS121X_addr<<1), cmdW, 2 , 100);
  return ADS121X_RREG(0);
}
/*---------------------------*/
/*      NASTAVENÍ REGISTRU   */
/*---------------------------*/

//0-intern 1-extern  - vrátí 0 při úspěchu
uint8_t ADS121X_VREF(uint8_t mode){
  mode = mode & 0x01; //pro klid srdicka
  uint8_t cmd;
  cmd = ADS121X_RREG(0);
  cmd = cmd & 0xfe;
  cmd = cmd | mode;
  uint8_t out = ADS121X_WREG(cmd);
  if((out&0x01) == mode)
  {
    return 0;
  }else{
    return 1;
  }
}

//nastavení kanálu mux  -vrátí 0 při úspěchu, 1 při špatném zadání , 2 jiná chyba (tested)
uint8_t ADS121X_MUX(uint8_t AINP, uint8_t AINN){
  uint8_t cmd;
  cmd = ADS121X_RREG(0);
  cmd = cmd & 0x1f;
  switch (AINP){
  case AIN0:
    if (AINN == AIN1)
    {
      cmd = cmd | 0x00;
    }else if (AINN == AGND)
    {
      cmd = cmd | 0x60;
    }else{
      return 1;
    }
    break;
  case AIN1:
    if (AINN == AIN2)
      {
        cmd = cmd | 0x40;
      }else if (AINN == AGND)
      {
        cmd = cmd | 0x80;
      }else{
      return 1;
      }
    break;
  case AIN2:
    if (AINN == AIN3)
      {
        cmd = cmd | 0x20;
      }else if (AINN == AGND)
      {
        cmd = cmd | 0xa0;
      }else{
      return 1;
      }
    break;
  case AIN3:
    if (AINN == AGND)
      {
        cmd = cmd | 0xc0;
      }else{
      return 1;
      }
    break;
  case calibration:
    cmd = cmd | 0xe0;
    break;
  default:
    return 1;
    break;
  }
  uint8_t out = ADS121X_WREG(cmd);
  if(out == cmd){
    return 0;
  }else{
    return 2;
  }
}

//nastavení conversion modu 0-single shot 1-continuous
uint8_t ADS121X_CM(uint8_t mode){
  mode |= 0x01;
  uint8_t cmd;
  cmd = ADS121X_RREG(0);
  cmd = 0xFD & cmd;
  cmd = cmd | (mode<<1);
  uint8_t out = ADS121X_WREG(cmd);
  if((out&0x02) == (mode<<1))
  {
    return 0;
  }else{
    return 1;
  }
}

//nastavení zisku-vrátí 0 při úspěchu, 1 při špatném zadání , 2 jiná chyba
uint8_t ADS121X_GRAIN(uint8_t GRAIN)
{
  uint8_t cmd;
  cmd = ADS121X_RREG(0);
  cmd = cmd & 0xef;
  switch (GRAIN)
  {
  case 1:
    break;
  case 4:
    cmd = cmd | 0x10;
    break;
  default:
    return 1;
    break;
  }
  uint8_t out = ADS121X_WREG(cmd);
  if(out == cmd){
    return 0;
  }else{
    return 1;
  }
}

/*nastavení datarate/sample speed -vrátí 0 při úspěchu, 1 při špatném zadání , 2 jiná chyba (tested)*/
uint8_t ADS121X_DR(uint16_t datarate){
  uint8_t cmd;
  cmd = ADS121X_RREG(0);
  cmd = cmd & 0xFC;
  switch (datarate)
  {
  case 20:

    break;
  case 90:
    cmd = cmd | 0x04;
    break;
  case 330:
    cmd = cmd | 0x08;
    break;
  case 1000:
    cmd = cmd | 0xc;
    break;
  default:
    return 1;
    break;
  }
  uint8_t out = ADS121X_WREG(cmd);
  if(out == cmd){
    return 0;
  }else{
    return 2;
  }
}

/*---------------------------*/
/*    inicializační funkce   */
/*---------------------------*/

//kalibrační rutina změří off-set ADC (tested)
void ADS121X_cal(void){
  uint8_t cmd_puvodni = ADS121X_RREG(0);
  int32_t tmp = 0; 
  ADS121X_MUX(calibration, calibration);
  ADS121X_CM(0);

  for (uint8_t i = 0; i < 10; i++)
  {
    ADS121X_start();
    while (ADS121X_ready() == 0)
    {
      
    }
    tmp += ADS121X_read();
  }
  tmp /= 10;
  offset = (int32_t)tmp;
  ADS121X_WREG(cmd_puvodni);
}

//inicializace (tested)
void ADS121X_init(void)
{
  //reset
  static uint8_t reset [1] = {0x06};
  HAL_I2C_Master_Transmit(&hi2c1, (ADS121X_addr<<1), reset , 1, 100);
}


//zjistí napětí na ADC a očistí o offset (single)
int32_t ADS121X_meas_sg(){
  ADS121X_start();
  int32_t tmp;
  while (ADS121X_ready() == 0)
  {
      
  }
  tmp = ADS121X_read();
  tmp -= offset;
  return tmp;
}

int32_t ADS121X_meas_ct(){
  int32_t tmp;
  while (ADS121X_ready() == 0)
  {
      
  }
  tmp = ADS121X_read();
  tmp -= offset;
  return tmp;
}

float ADS121X_Voltage(int32_t ADC, uint8_t GRAIN, uint8_t VREF){
      float out = ADC;
      if(VREF == 0){
        out *= 2.048;
      }else{
        out *= 3.3;
      }
        out /= 0x7fffff;
      if(GRAIN){
        out /= 4;
      }
    return out;
}
