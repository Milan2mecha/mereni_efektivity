/**
  ******************************************************************************
  * @file     lib.c
  * @author   Auto-generated by STM32CubeIDE
  * @version  V1.0
  * @date     19/09/2024 19:17:24
  * @brief    Default under dev library file.
  ******************************************************************************
*/

/* Includes ------------------------------------------------------------------*/
#include "stm32f1xx_hal.h"
#include "ADS121X.h"
extern I2C_HandleTypeDef hi2c1;
int32_t offset = 0;

/*---------------------------*/
/*   Základní práce s reg    */
/*---------------------------*/

//čtení ADC
int32_t ADS121X_read(void)
{
  uint8_t buff[3];
  int32_t out = 0;
  HAL_I2C_Mem_Read(&hi2c1, (ADS121X_addr<<1), 0x10, 1, buff, 3, 10);
  out = (uint32_t)buff[0];
  out = out <<8;
  out |= (uint32_t)buff[1];
  out = out <<8;
  LSB |= (uint32_t) buff[2];
  return out;
}

// Čtení registru nastavení
uint8_t ADS121X_RREG(uint8_t num)
{
  uint8_t status  = 0;
  HAL_I2C_Mem_Read(&hi2c1, (ADS121X_addr<<1), (0b00100000 | (num<<2)), 1, &status, 1, 10);
  return status;
}

//příkaz start
void ADS121X_start(void){
  uint8_t cmd = 0x08;
  HAL_I2C_Master_Transmit(&hi2c1, (ADS121X_addr<<1), &cmd, 1 , 10);
}

//je k dispozici výsledek nové konverze pokud ano vrátí 1
uint8_t ADS121X_ready(void){
  if ((ADS121X_RREG(1)&0x80)==0)
  {
    return 0;
  }else{
    return 1;
  }
}

void ADS121X_POWERDOWN(void){
  static uint8_t PD = 0x02;
  HAL_I2C_Master_Transmit(&hi2c1, (ADS121X_addr<<1), &PD , 1, 100);
}
/*---------------------------*/
/*      NASTAVENÍ REGISTRU   */
/*---------------------------*/

//0-intern 1-extern
uint8_t ADS121X_VREF(uint8_t mode){
  uint8_t cmd[2];
  cmd[0] = 0b01000000;
  cmd[1] = ADS121X_RREG(0);
  cmd[1] = cmd[1]&0xFE;
  if (mode == 1)
  {
    cmd[1] = cmd[1] | 0x01;
    HAL_I2C_Master_Transmit(&hi2c1, (ADS121X_addr<<1), cmd, 2 , 10);
    if((0x0C&ADS121X_RREG(0))==0x0C){
      return 1;
    }else{
      return 0;
    }
  }else{
	  HAL_I2C_Master_Transmit(&hi2c1, (ADS121X_addr<<1), cmd, 2 , 10);
	  return 0;
  }
}

//nastavení kanálu mux
uint8_t ADS121X_MUX(uint8_t AINP, uint8_t AINN){
  uint8_t cmd [2];
  cmd[0] = 0b01000000;
  cmd[1] = ADS121X_RREG(0);
  cmd[1] = 0x1F&cmd[1];
  
  switch (AINP)
  {
  case AIN0:
    if (AINN == AIN1)
    {
      HAL_I2C_Master_Transmit(&hi2c1, (ADS121X_addr<<1), cmd, 2 , 10);
    }else if (AINN == AGND)
    {
      cmd[1] = 0x60|cmd[1]; 
      HAL_I2C_Master_Transmit(&hi2c1, (ADS121X_addr<<1), cmd, 2 , 10);
    }
      return ADS121X_RREG(0);;
    
    break;
  case AIN1:
    if (AINN == AIN2)
      {
        cmd[1] = 0x40|cmd[1]; 
        HAL_I2C_Master_Transmit(&hi2c1, (ADS121X_addr<<1), cmd, 2 , 10);
      }else if (AINN == AGND)
      {
        cmd[1] = 0x80|cmd[1]; 
        HAL_I2C_Master_Transmit(&hi2c1, (ADS121X_addr<<1), cmd, 2 , 10);
      }
      return ADS121X_RREG(0);;
    break;
  case AIN2:
    if (AINN == AIN3)
      {
        cmd[1] = 0x20|cmd[1]; 
        HAL_I2C_Master_Transmit(&hi2c1, (ADS121X_addr<<1), cmd, 2 , 10);
      }else if (AINN == AGND)
      {
        cmd[1] = 0x90|cmd[1]; 
        HAL_I2C_Master_Transmit(&hi2c1, (ADS121X_addr<<1), cmd, 2 , 10);
      }
      return ADS121X_RREG(0);
      
    break;
  case AIN3:
    if (AINN == AGND)
      {
        cmd[1] = 0xC0|cmd[1]; 
        HAL_I2C_Master_Transmit(&hi2c1, (ADS121X_addr<<1), cmd, 2 , 10);
      }
        return ADS121X_RREG(0);
    break;
  case calibration:
    cmd[1] = 0xE0|cmd[1];
    HAL_I2C_Master_Transmit(&hi2c1, (ADS121X_addr<<1), cmd, 2 , 10);
    return ADS121X_RREG(1);
    break;
  default:
    return ADS121X_RREG(0);
    break;
  }
}

//nastavení conversion modu 0-single shot 1-continuous
uint8_t ADS121X_CM(uint8_t mode){
  uint8_t cmd [2];
  cmd[0] = 0b01000000;
  cmd[1] = ADS121X_RREG(0);
  cmd[1] = 0xFD&cmd[1];
  if (mode == 1)
  {
    cmd[1] = cmd[1]|0x02;
    HAL_I2C_Master_Transmit(&hi2c1, (ADS121X_addr<<1), cmd, 2 , 10);
    ADS121X_start();
    if((0x02&ADS121X_RREG(0))==0x02){
      return 1;
    }else{
      return 0;
    }
  }else{
    HAL_I2C_Master_Transmit(&hi2c1, (ADS121X_addr<<1), cmd, 2 , 10);
      return 0;
  }
}

/*nastavení zisku*/
uint8_t ADS121X_GRAIN(uint8_t GRAIN)
{
  uint8_t cmd [2];
  cmd[0] = 0b01000000;
  cmd[1] = ADS121X_RREG(0);
  switch (GRAIN)
  {
  case 1:
    cmd[1] = cmd[1]&0xEF;
    HAL_I2C_Master_Transmit(&hi2c1, (ADS121X_addr<<1), cmd, 2 , 10);
    break;
  case 4:
    cmd[1] = cmd[1]|0x10;
    HAL_I2C_Master_Transmit(&hi2c1, (ADS121X_addr<<1), cmd, 2 , 10);
    break;
  default:
    break;
  }
  return ADS121X_RREG(0);
}

/*nastavení datarate/sample speed vrací DR povolené hoodnoty 20,90,330,1000 jinak default 20, chyba 0*/
uint16_t ADS121X_DR(uint16_t datarate){
  uint8_t cmd[2];
  cmd[0] = 0b01000000;
  cmd[1] = ADS121X_RREG(0);
  cmd[1] = cmd[1]&0xFC;
  switch (datarate)
  {
  case 90:
    cmd[1] = cmd[1] | 0x04;
    HAL_I2C_Master_Transmit(&hi2c1, (ADS121X_addr<<1), cmd, 2 , 10);
    if((0x0C&ADS121X_RREG(0))==0x04){
      return 90;
    }else{
      return 0;
    }
    break;
  case 330:
    cmd[1] = cmd[1] | 0x08;
    HAL_I2C_Master_Transmit(&hi2c1, (ADS121X_addr<<1), cmd, 2 , 10);
    if((0x0C&ADS121X_RREG(0))==0x08){
      return 330;
    }else{
      return 0;
    }
    break;
  case 1000:
    cmd[1] = cmd[1] | 0x0C;
    HAL_I2C_Master_Transmit(&hi2c1, (ADS121X_addr<<1), cmd, 2 , 10);
    if((0x0C&ADS121X_RREG(0))==0x0C){
      return 1000;
    }else{
      return 0;
    }
    break;
  default:
  /*defalt 20sps*/
    //cmd[1] = cmd[1] | 0x00;
    HAL_I2C_Master_Transmit(&hi2c1, (ADS121X_addr<<1), cmd, 2 , 10);
    if((0x0C&ADS121X_RREG(0))==0x00){
      return 20;
    }else{
      return 0;
    }
    break;
  }
}

/*---------------------------*/
/*    inicializační funkce   */
/*---------------------------*/

//kalibrační rutina změří off-set ADC
void ADS121X_cal(void){
  int32_t tmp = 0; 
  ADS121X_MUX(calibration, calibration);
  ADS121X_CM(0);
  ADS121X_start();
  for (uint8_t i = 0; i < 10; i++)
  {
    while (ADS121X_ready() == 0)
    {
      
    }
    tmp += ADS121X_read();
  }
  tmp /= 10;
  offset = (int32_t)tmp;
}

//inicializace
void ADS121X_init(void)
{
  //reset
  static uint8_t reset [1] = {0x07};
  HAL_I2C_Master_Transmit(&hi2c1, (ADS121X_addr<<1), reset , 1, 100);
}

int32_t ADS121X_measure_sg(){
  ADS121X_start();
  int32_t tmp;
  while (ADS121X_ready() == 0)
  {
      
  }
  tmp = ADS121X_read();
  tmp -= offset;
  return tmp;
}

int32_t ADS121X_measure(){
  int32_t tmp;
  while (ADS121X_ready() == 0)
  {
      
  }
  tmp = ADS121X_read();
  tmp -= offset;
  return tmp;
}
